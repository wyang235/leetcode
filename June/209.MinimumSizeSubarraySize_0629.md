### :x: 第一遍：双指针，2/3个case过了
```
class Solution {
  public int minSubArrayLen(int target, int[] nums) {
    int start = 0;
    int sum = 0;
    int subLength = 0;
    int rsLength = Integer.MAX_VALUE;
    for(int end=0; end<nums.length; end++) {
      sum += nums[end];
      if(sum >= target) {
        subLength++;
        start = end;
        if(subLength < rsLength) {
          rsLength = subLength;
        }
      }
    }
    return rsLength == Integer.MAX_VALUE ? 0 : rsLength;
  }
}
```
查解析发现line11应该用while循环，而且区间向前移动的时候，sum需要减掉开头不要的数

### :white_check_mark: 第二遍，双指针，过了（标答版）
```
class Solution {
  public int minSubArrayLen(int target, int[] nums) {
    int start = 0;
    int sum = 0;
    int rsLength = Integer.MAX_VALUE;
    for(int end=0; end<nums.length; end++) {
      sum += nums[end];
      while(sum >= target) {
        rsLength = Math.min(rsLength, end - start + 1);
        sum -= nums[start];
        start++;
      }
    }
    return rsLength == Integer.MAX_VALUE ? 0 : rsLength;
  }
}
```
需要while循环是因为得把sum区间挪到下一个小于target的地方，再重新开始计算区间。只减掉一次start会漏减。

### :white_check_mark: 第三遍，双指针，过了。基于第一遍的基础改的
```
class Solution {
  public int minSubArrayLen(int target, int[] nums) {
    int start = 0;
    int sum = 0;
    int subLength = 0;
    int rsLength = Integer.MAX_VALUE;
    for(int end=0; end<nums.length; end++) {
      sum += nums[end];
      subLength++;
      while(sum >= target) {
        if(subLength < rsLength) {
          rsLength = subLength;
        }
        sum -= nums[start];
        subLength--;
        start++;
      }
    }
    return rsLength == Integer.MAX_VALUE ? 0 : rsLength;
  }
}
```
根据第一遍的版本，加上start++，if改成while之后发现还是只能过1/3case，debug后发现line63的start++位置给错了，之前给到了sum-=nums[start]的前面，导致sum减错数了
